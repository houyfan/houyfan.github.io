<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>sql属性的参数映射上的类型处理程序为null的问题</title>
    <link href="/2023/08/14/sql%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%A0%E5%B0%84%E4%B8%8A%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%B8%BAnull%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/14/sql%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%A0%E5%B0%84%E4%B8%8A%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E4%B8%BAnull%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>Type handler was null on parameter mapping for property ‘specificationTypes’</p><p>出错是因为传入的参数类型为list,而查询条件为单个元素直接写入单个元素就会造成类型不匹配。</p><p>例如：<br>我有一个example，还有一个list，通过ArrayList向mapper中传值</p><select id="getMainInfo" parameterType="example" resultType="java.util.List">  select name from table   where     name in  <foreach collection="list" item="param"  open="(" close=")" separator=",">      #{param.name}//这里直接用#{name}，就会报错  </foreach>   </select><p>&lt; foreach&gt;标签的使用：<br>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach元素的属性主要有item，index，collection，open，separator，close。item表示集合中每一个元素进行迭代时的别名，index指定一个名字，用于表示在迭代过程中，每次迭代到的位置，open表示该语句以什么开始，separator表示在每次进行迭代之间以什么符号作为分隔符，close表示以什么结束，在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有一下3种情况：</p><ol><li>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list .</li><li>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array .</li><li>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key.</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mysql索引底层原理</title>
    <link href="/2023/07/11/Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <url>/2023/07/11/Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Mysql-索引底层数据结构"><a href="#一、Mysql-索引底层数据结构" class="headerlink" title="一、Mysql 索引底层数据结构"></a><strong>一、Mysql 索引底层数据结构</strong></h2><ol><li>哈希表（Hash）</li></ol><p>哈希表是做数据快速检索的有效利器。</p><p>哈希算法：也叫散列算法，就是把任意值(key)通过哈希函数变换为固定长度的 key 地址，通过这个地址进行具体数据的数据结构。</p><p>考虑这个数据库表 user，表中一共有 7 个数据，我们需要检索 id=7 的数据，SQL 语法是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">select \* from user where id=7;<br></code></pre></td></tr></table></figure><p>哈希算法首先计算存储 id=7 的数据的物理地址 addr=hash(7)=4231，而 4231 映射的物理地址是 0x77，0x77 就是 id=7 存储的额数据的物理地址，通过该独立地址可以找到对应 user_name=’g’这个数据。这就是哈希算法快速检索数据的计算过程。</p><p>但是哈希算法有数据碰撞的问题，也就是哈希函数可能对不同的 key 会计算出同一个结果，比如 hash(7)可能跟 hash(199)计算出来的结果一样，也就是不同的 key 映射到同一个结果了，这就是碰撞问题。解决碰撞问题的一个常见处理方式就是链地址法，即用链表把碰撞的数据接连起来。计算哈希值之后，还需要检查该哈希值是否存在碰撞数据链表，有则一直遍历到链表尾，直达找到真正的 key 对应的数据为止。</p><p>哈希算法实现的索引虽然可以做到快速检索数据，但是没办法做数据高效范围查找，因此哈希索引是不适合作为 Mysql 的底层索引的数据结构。</p><p>2.二叉查找树(BST)</p><p>二叉查找树是一种支持数据快速查找的数据结构，二叉查找树的时间复杂度是 O(lgn)，普通的二叉查找树有个致命缺点：极端情况下会退化为线性链表，二分查找也会退化为遍历查找，时间复杂退化为 O（N），检索性能急剧下降。比如以下这个情况，二叉树已经极度不平衡了，已经退化为链表了，检索速度大大降低。此时检索 id=7 的数据的所需要计算的次数已经变为 7 了。</p><p><img src="https://pic1.zhimg.com/80/v2-1cc416d59d4c44cf029e9e2103347bb8_1440w.webp" alt="img"></p><p>在数据库中，数据的自增是一个很常见的形式，比如一个表的主键是 id，而主键一般默认都是自增的，如果采取二叉树这种数据结构作为索引，那上面介绍到的不平衡状态导致的线性查找的问题必然出现。因此，简单的二叉查找树存在不平衡导致的检索性能降低的问题，是不能直接用于实现 Mysql 底层索引的。</p><p>3.AVL 树和红黑树</p><p>自调整平衡状态的二叉树有 AVL 树和红黑树。</p><p>红黑树是一颗会自动调整树形态的树结构，比如当二叉树处于一个不平衡状态时，红黑树就会自动左旋右旋节点以及节点变色，调整树的形态，使其保持基本的平衡状态（时间复杂度为 O（logn）），也就保证了查找效率不会明显减低。</p><p>红黑树并没有完全解决二叉查找树虽然这个“右倾”趋势远没有二叉查找树退化为线性链表那么夸张，但是数据库中的基本主键自增操作，主键一般都是数百万数千万的，如果红黑树存在这种问题，对于查找性能而言也是巨大的消耗，数据库不可能忍受这种无意义的等待的。</p><p><img src="https://pic1.zhimg.com/80/v2-60cea4af963b156ee5f40030977ab77c_1440w.webp" alt="img"></p><p> AVL 树是个绝对平衡的二叉树，他在调整二叉树的形态上消耗的性能会更多。</p><p> AVL 树的优点：</p><ol><li>不错的查找性能（O（logn）），不存在极端的低效查找的情况。</li><li>可以实现范围查找、数据排序。</li></ol><p>数据库查询数据的瓶颈在于磁盘 IO，如果使用的是 AVL 树，我们每一个树节点只存储了一个数据，我们一次磁盘 IO 只能取出来一个节点上的数据加载到内存里，那比如查询 id=7 这个数据我们就要进行磁盘 IO 三次，这是多么消耗时间的。所以我们设计数据库索引时需要首先考虑怎么尽可能减少磁盘 IO 的次数。</p><p>磁盘 IO 有个有个特点，就是从磁盘读取 1B 数据和 1KB 数据所消耗的时间是基本一样的，我们就可以根据这个思路，我们可以在一个树节点上尽可能多地存储数据，一次磁盘 IO 就多加载点数据到内存，这就是 B 树，B+树的的设计原理了。</p><p>4.B 树</p><p>下面这个 B 树，每个节点限制最多存储两个 key，一个节点如果超过两个 key 就会自动分裂。比如下面这个存储了 7 个数据 B 树，只需要查询两个节点就可以知道 id=7 这数据的具体位置，也就是两次磁盘 IO 就可以查询到指定数据，优于 AVL 树。</p><p><img src="https://pic2.zhimg.com/80/v2-f508590121487b595c4ad4fa83d8aa15_1440w.webp" alt="img"></p><p>B 树的优点：</p><ol><li>优秀检索速度，时间复杂度：B 树的查找性能等于 O（h*logn），其中 h 为树高，n 为每个节点关键词的个数；</li><li>尽可能少的磁盘 IO，加快了检索速度；</li><li>可以支持范围查找。</li></ol><p>4.B+树</p><p>B 树和 B+树的区别</p><p>第一，B 树一个节点里存的是数据，而 B+树存储的是索引（地址），所以 B 树里一个节点存不了很多个数据，但是 B+树一个节点能存很多索引，B+树叶子节点存所有的数据。</p><p>第二，B+树的叶子节点是数据阶段用了一个链表串联起来，便于范围查找。</p><p><img src="https://pic2.zhimg.com/80/v2-bda6661499c51dcff63eb12fd4b3795d_1440w.webp" alt="img"></p><p>通过 B 树和 B+树的对比我们看出，B+树节点存储的是索引，在单个节点存储容量有限的情况下，单节点也能存储大量索引，使得整个 B+树高度降低，减少了磁盘 IO。其次，B+树的叶子节点是真正数据存储的地方，叶子节点用了链表连接起来，这个链表本身就是有序的，在数据范围查找时，更具备效率。因此 <strong>Mysql 的索引用的就是 B+树，B+树在查找效率、范围查找中都有着非常不错的性能</strong>。</p><h2 id="二、Innodb-引擎和-Myisam-引擎的实现"><a href="#二、Innodb-引擎和-Myisam-引擎的实现" class="headerlink" title="二、Innodb 引擎和 Myisam 引擎的实现"></a><strong>二、Innodb 引擎和 Myisam 引擎的实现</strong></h2><p>Mysql 底层数据引擎以插件形式设计，有 Innodb 引擎、 Myisam 引擎和Memory引擎。</p><p>MyISAM 虽然数据查找性能极佳，但是不支持事务处理。Innodb 最大的特色就是支持了 ACID 兼容的事务功能，而且他支持行级锁。</p><p>Innodb 创建表后生成的文件有：</p><ul><li>frm:创建表的语句</li><li>idb:表里面的数据+索引文件</li></ul><p>Myisam 创建表后生成的文件有</p><ul><li>frm:创建表的语句</li><li>MYD:表里面的数据文件（myisam data）</li><li>MYI:表里面的索引文件（myisam index）</li></ul><p>从生成的文件看来，这两个引擎底层数据和索引的组织方式并不一样，MyISAM 引擎把数据和索引分开了，一人一个文件，这叫做非聚集索引方式；Innodb 引擎把数据和索引放在同一个文件里了，这叫做聚集索引方式。下面将从底层实现角度分析这两个引擎是怎么依靠 B+树这个数据结构来组织引擎实现的。</p><ol><li>MyISAM 引擎的底层实现（非聚集索引方式）</li></ol><p>MyISAM 用的是非聚集索引方式，即数据和索引落在不同的两个文件上。MyISAM 在建表时以主键作为 KEY 来建立主索引 B+树，树的叶子节点存的是对应数据的物理地址。我们拿到这个物理地址后，就可以到 MyISAM 数据文件中直接定位到具体的数据记录了。</p><p><img src="https://pic1.zhimg.com/80/v2-d9a03627e8e1319e46f42e6963c35e30_1440w.webp" alt="img"></p><p>当我们为某个字段添加索引时，我们同样会生成对应字段的索引树，该字段的索引树的叶子节点同样是记录了对应数据的物理地址，然后也是拿着这个物理地址去数据文件里定位到具体的数据记录。</p><p>​    2.Innodb 引擎的底层实现（聚集索引方式）</p><p>InnoDB 是聚集索引方式，因此数据和索引都存储在同一个文件里。首先 InnoDB 会根据主键 ID 作为 KEY 建立索引 B+树，如左下图所示，而 B+树的叶子节点存储的是主键 ID 对应的数据，比如在执行 select * from user_info where id=15 这个语句时，InnoDB 就会查询这颗主键 ID 索引 B+树，找到对应的 user_name=’Bob’。</p><p>这是建表的时候 InnoDB 就会自动建立好主键 ID 索引树，这也是为什么 Mysql 在建表时要求必须指定主键的原因。给 user_name 这个字段加索引，那么 InnoDB 就会建立 user_name 索引 B+树，节点里存的是 user_name 这个 KEY，<strong>叶子节点存储的数据的是主键 KEY</strong>。拿到主键 KEY 后，InnoDB 才会去主键索引树里根据刚在 user_name 索引树找到的主键 KEY 查找到对应的数据。</p><p><img src="https://pic2.zhimg.com/80/v2-6e16b355e3d0f05ed8bfb0f7c71de8f1_1440w.webp" alt="img"></p><p> InnoDB 只在主键索引树的叶子节点存储了具体数据，但是其他索引树不存具体数据要先找到主键，再在主键索引树找到对应的数据， InnoDB 需要节省存储空间。一个表里可能有很多个索引，InnoDB 都会给每个加了索引的字段生成索引树，如果每个字段的索引树都存储了具体数据，那么这个表的索引数据文件就变得非常巨大（数据极度冗余了）。从节约磁盘空间的角度来说，真的没有必要每个字段索引树都存具体数据，通过这种看似“多此一举”的步骤，在牺牲较少查询的性能下节省了巨大的磁盘空间，这是非常有值得的。</p><p>在进行 InnoDB 和 MyISAM 特点对比时谈到，MyISAM 查询性能更好，从上面索引文件数据文件的设计来看也可以看出原因：MyISAM 直接找到物理地址后就可以直接定位到数据记录，但是 InnoDB 查询到叶子节点后，还需要再查询一次主键索引树，才可以定位到具体数据。等于 MyISAM 一步就查到了数据，但是 InnoDB 要两步，那当然 MyISAM 查询性能更高。</p><p>给表里的字段加索引的一些情况：</p><ol><li>较频繁的作为查询条件的字段应该创建索引；</li><li>唯一性太差的字段不适合单独创建索引，即使该字段频繁作为查询条件；</li><li>更新非常频繁的字段不适合创建索引。</li></ol><p>Memory引擎</p><p>将数据存在内存，为了提高数据的访问速度，每一个表实际上和一个磁盘文件关联。文件是frm。</p><p>（1）支持的数据类型有限制，比如：不支持TEXT和BLOB类型，对于字符串类型的数据，只支持固定长度的行，VARCHAR会被自动存储为CHAR类型；</p><p>（2）支持的锁粒度为表级锁。所以，在访问量比较大时，表级锁会成为MEMORY存储引擎的瓶颈；</p><p>（3）由于数据是存放在内存中，一旦服务器出现故障，数据都会丢失；</p><p>（4）查询的时候，如果有用到临时表，而且临时表中有BLOB，TEXT类型的字段，那么这个临时表就会转化为MyISAM类型的表，性能会急剧降低；</p><p>（5）默认使用hash索引。</p><p>（6）如果一个内部表很大，会转化为磁盘表。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>axios和ajax区别</title>
    <link href="/2023/07/10/axios%E5%92%8Cajax%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/07/10/axios%E5%92%8Cajax%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>axios是通过<a href="https://so.csdn.net/so/search?q=promise&spm=1001.2101.3001.7020">promise</a>实现对ajax技术的一种封装，就像jQuery实现ajax封装一样。<br>简单来说： <a href="https://so.csdn.net/so/search?q=ajax&spm=1001.2101.3001.7020">ajax</a>技术实现了网页的局部数据刷新，axios实现了对ajax的封装。<br>axios是ajax ajax不止axios。</p><h2 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h2><h3 id="ajax："><a href="#ajax：" class="headerlink" title="ajax："></a>ajax：</h3><p>本身是针对MVC的编程,不符合现在前端MVVM的浪潮<br>基于原生的XHR开发(<em>xhr是浏览器提供的JavaScript对象，通过它，可以请求服务器上的数据资源，之前所学的jquery的ajax函数，就是基于xhr对象封装出来的</em>。)，XHR本身的架构不清晰，已经有了fetch的替代方案<br>JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务</p><h3 id="axios："><a href="#axios：" class="headerlink" title="axios："></a>axios：</h3><p>从 node.js 创建 http 请求<br>支持 Promise API<br>客户端支持防止CSRF<br>提供了一些并发请求的接口（重要，方便了很多的操作）</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
